# 并发

## 并发与并行

- 并发：单个CPU的操作系统在进行多线程操作时，将CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段内只运行一个线程，其他线程处于挂起状态。
- 并行：对于多CPU系统进行多线程操作，一个CPU在执行一个线程时，另一个CPU执行另一个线程。两个线程互不抢CPU资源，可以**同时**进行。

## 多线程加锁

应对多线程，同一时刻的同一份资源只能让一个线程获取，所以需要加锁

- 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据
- 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据（CAS），如果别人修改了数据则放弃操作，否则执行操作
- 自旋锁：当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环
  - 节省了线程状态切换带来的开销

### 悲观锁的优缺点

优点

- 悲观并发控制采取的是保守策略：“先取锁，成功了才访问数据”，这保证了数据获取和修改都是有序进行的，因此适合在写多读少的环境中使用
- 在乐观锁也无法提供更好的性能前提下，悲观锁却可以做到保证数据的安全性

缺点

- 由于需要加锁，而且可能面临锁冲突甚至死锁的问题
- 悲观并发控制增加了系统的额外开销，降低了系统的效率，同时也会降低了系统的并行性

### 乐观锁的缺点

优点

- 乐观并发控制没有实际加锁，所以没有额外开销，也不错出现死锁问题，适用于读多写少的并发场景
- 因为没有额外开销，所以能极大提高数据库的性能

缺点

- ABA问题
- 自旋时间长开销大
- 只能保证一个共享变量的原子操作

## volatile

- 可见性
- 原子性
- 禁止指令重排序

## C++互斥锁

`std::mutex`问题：临界区中因为抛出异常或return等操作导致没有解锁就退出的问题

`std::lock_guard`：提供自动为互斥量上锁和解锁，在构造时上锁，在销毁时解锁
