# 设计模式

- **单例模式**：能够保证整个应用中有且只有一个实例
- 简单工厂模式：定义一个用以创建对象的工厂, 根据不同的**条件**生成不同的**对象**
- 工厂方法模式：针对每一种产品提供一个工厂类，通过不同的**工厂**实例来创建不同的**产品**实例
- 抽象工厂模式：针对产品族，不需要明确指定具体的产品类
- 代理模式：设置一个中间代理来控制访问原目标对象
- **外观模式**：为系统向外界提供一个统一的接口
- 观察者模式：当对象间存在一对多关系时，则使用观察者模式。当一个对象被修改时，则会自动通知依赖它的对象
- 适配器模式：将一个类的接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作
- **桥接模式**：将抽象与实现分离，使它们都可以独立的变化
- **建造者模式**：使用多个简单的对象一步一步构建成一个复杂的对象
- 原型模式：用于创建重复的对象，同时又能保证性能

```java
//单例模式
public class Singleton {
	 private volatile static Singleton instance;//volatile禁用JVM的指令重排
	 // 构造方法私有化
	 private Singleton() {}
	 // 静态方法返回该实例
	 public static Singleton geInstance() {
		 //先判断对象是否已经实例过，没有实例化过才进⼊加锁代码
		 if (instance == null) {
			 synchronized (Singleton.class) {
         // 防止二次创建实例
				 if (instance == null) {
				 	instance = new Singleton();
				 }
			 }
		 }
		 return uniqueInstance;
	 }
}
```

## 设计模式的六大原则

- 单一职责原则SRP：一个类应该只负责一个职责
- 开闭原则OCP：对扩展开放，对修改封闭。
- 里式替换原则LSP：任何父类可以出现的地方，子类一定可以出现
- 依赖倒置原则DIP：针对接口编程，依赖于抽象而不依赖于具体
- 接口隔离原则ISP：使用多个隔离的接口，比使用单个接口要好，降低类之间的耦合度
- 迪米特法则（最少知道原则）：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立
