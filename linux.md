# Linux

## 5种IO模型

阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动的IO模型、异步IO模型

## 文件权限

### 1、chmod：改变文件或目录的访问权限

chmod [who] [+ | - | =] [mode] 文件名?

chmod 777：r=4,w=2,x=1

第一个数字表示文件所有者的权限

第二个数字表示与文件所有者同属一个用户组的其他用户的权限

第三个数字表示 其它用户组的权限

### 2、chgrp：改变文件或目录所属的组

chgrp [选项] group filename?

举例：改变/opt/local /book/及其子目录下的所有文件的属组为book

`chgrp - R book /opt/local /book `

### 3、chown 命令：更改某个文件或目录的属主和属组

chown [选项] 用户或组 文件

举例：把目录/his及其下的所有文件和子目录的属主改成wang，属组改成users

`chown - R wang.users /his `

## mmap

mmap内存映射函数，使得进程之间通过映射同一个文件实现共享内存。 文件被映射到进程地址空间后，进程可以像访问内存一样对文件进行访问，不必再调用read()，write()等操作

## Linux内存管理

### 虚拟地址

#### 虚拟地址是什么

- 为了充分利用和管理系统内存资源，Linux采用虚拟内存管理技术，利用虚拟内存技术让每个进程都有 `4GB` 互不干涉的虚拟地址空间
- 每个进程都有独立的虚拟地址空间，进程访问的虚拟地址并不是真正的物理地址；
- 虚拟地址可通过每个进程上的页表(在每个进程的内核虚拟地址空间)与物理地址进行映射，获得真正物理地址；
- 如果虚拟地址对应物理地址不在物理内存中，则产生缺页中断，真正分配物理地址，同时更新进程的页表；如果此时物理内存已耗尽，则根据内存替换算法淘汰部分页面至物理磁盘中

#### 虚拟地址的好处

- 避免用户直接访问物理内存地址，防止一些破坏性操作，保护操作系统
- 每个进程都被分配了4GB的虚拟内存，用户程序可使用比实际物理内存更大的地址空间

#### 虚拟地址空间划分

- 用户空间
- 内核空间

![img](images/76201b86-9028-11ea-b7f2-00163e2e672a.jpg)

![img](images/767d49d2-9028-11ea-b7f2-00163e2e672a.jpg)

### 物理地址

#### 虚拟地址转物理地址

把虚拟地址转换成内存的物理地址，这中间涉及利用 `MMU` 内存管理单元（Memory Management Unit ) 对虚拟地址分段和分页地址转换

![img](images/762acd42-9028-11ea-b7f2-00163e2e672a.jpg)

#### 物理内存划分

ZONE_DMA：`DMA`内存区域。直接映射到内核的地址空间

ZONE_NORMAL：普通内存区域。直接映射到内核的地址空间

ZONE_HIGHMEM：高端内存区域。不进行直接映射，可以通过永久映射和临时映射进行这部分内存页的访问

**4G进程地址空间被划分两部分，内核空间和用户空间**

### 用户空间

用户进程能访问的是用户空间，每个进程都有自己独立的用户空间

用户进程通常只能访问用户空间的虚拟地址，只有在执行内陷操作或系统调用时才能访问内核空间

#### 进程与内存

进程在用户空间中被划分为五个区域

- 栈
- 堆
- `bss`段：未初始化的全局变量
- `data`段：初始化的全局变量
- 代码（`text`）段

### 内核空间

mmap：是一种内存映射文件的方法，即将一个文件映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存

![img](images/76653bbc-9028-11ea-b7f2-00163e2e672a.jpg)

参考

http://news.eeworld.com.cn/mp/rrgeek/a88088.jspx

https://www.jianshu.com/p/fb345b94501f

### 内核态和用户态的区别

1. 用户态（User Mode）：运行用户程序
2. 内核态（Kernel Mode）：运行操作系统程序，操作硬件

- 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的
- 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。

### 内核态和用户态通信

- procfs(/proc)
- netlink

## IO多路复用

### 什么是IO多路复用

让单线程或单进程可以监听多个文件描述符，一旦某个文件描述符就绪，能够通知程序进行相应的读写操作

### 1、select

#### select缺点

- 单个进程可监视的fd数量被限制，32位机默认是1024个。64位机默认是2048
- 对socket进行扫描时是线性扫描，效率低
- 每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大

### 2、poll

和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。

#### poll缺点

- 大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。
- poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

#### 水平触发和边缘触发

- LT模式：level trigger。当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
- ET模式：edge trigger。当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。

### 3、epoll

#### epoll为什么要有EPOLLET触发模式？

如果采用EPOLLLT模式的话，系统中一旦有大量你不需要读写的就绪文件描述符，它们每次调用epoll_wait都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。而采用EPOLLET这种边缘触发模式的话，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！**这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。**

#### epoll优点

- 没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；
- 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；
  - 即epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。
- 内存拷贝，利用mmap()文件映射内存，加速与内核空间的消息传递；即epoll使用mmap减少复制开销。

### 区别

<img src="images/select_poll_epoll.jpg" alt="Image" style="zoom:70%;" />

参考

https://mp.weixin.qq.com/s/GCoczkOzDA2xfp8Nzb04dw

## IOCP

用于windows系统，非阻塞异步模型

## Epoll和IOCP的区别

- Epoll 用于 Linux 系统；而 IOCP 则是用于 Windows；
- Epoll 是当事件**资源满足时**发出可处理通知消息；而 IOCP 则是**当事件完成**时发出完成通知消息。
- 从应用程序的角度来看， Epoll 本质上来讲是**同步非阻塞**的，而 IOCP 本质上来讲则是**异步非阻塞**
- Epoll保持了事件通知与IO操作之间彼此的独立性，使用更加灵活

## 常用命令

`ps`：列出系统中当前运行的进程状态

```bash
ps -eo pid,ppid,%mem,%cpu,comm --sort=-%cpu | head
```

- `ps`：命令名字
- `-e`：选择所有进程
- `-o`：自定义输出格式
- `–sort=-%cpu`：基于 CPU 使用率对输出结果排序
- `head`：显示结果的前 10 行
- `PID`：进程的 ID
- `PPID`：父进程的 ID
- `%MEM`：进程使用的 RAM 比例
- `%CPU`：进程占用的 CPU 比例
- `Command`：进程名字

列出了由进程号为 `<pid>`的进程创建的所有线程

```bash
 ps -T -p <pid>
```

`free`：显示内存的使用情况

`top`：实时显示系统中各个进程的资源占用状况

![img](images/image-12.png)

- `PID`：进程的ID
- `USER`：进程所有者
- `PR`：进程的优先级别，越小越优先被执行
- `NInice`：值
- `VIRT`：进程占用的虚拟内存
- `RES`：进程占用的物理内存
- `SHR`：进程使用的共享内存
- `S`：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数
- `%CPU`：进程占用CPU的使用率
- `%MEM`：进程使用的物理内存和总内存的百分比
- `TIME+`：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。
- `COMMAND`：进程启动命令名称

定位某一个进程，观察 进程 `PID` 2438的 `CPU`和内存以及负载情况

```bash
top -p 2438
```

![img](images/image-13.png)

查看进程 `PID` 2438 的每一个线程占用 cpu 的情况

```bash
top -p 2438 -H
```

![img](images/image-14.png)

`tail`查看日志

```bash
命令格式: tail[必要参数][选择参数][文件]
-f 循环读取
-q 不显示处理信息
-v 显示详细的处理信息
-c<数目> 显示的字节数
-n<行数> 显示行数
-q, --quiet, --silent 从不输出给出文件名的首部
-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒
```

```bash
tail  -n  10   test.log   查询日志尾部最后10行的日志;
tail  -n +10   test.log   查询10行之后的所有日志;
tail  -fn 10   test.log   循环实时查看最后1000行记录(最常用的)
```

`grep`：查找文件里符合条件的字符串

gdb调试

<img src="images/gdb.jpg" alt="img" style="zoom:100%;" />
