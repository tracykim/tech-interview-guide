# 内存管理

## 内存分区

- 栈：由编译器自动分配和释放的，存放函数的参数值、局部变量的值等
- 堆：由程序员手动分配和释放，涉及的问题：“缓冲区溢出”、“内存泄露
- 静态（全局）存储区：存放全局变量和静态变量
- 常量存储区：存放常量，不允许修改
- 代码区：存放代码（如函数），CPU 执行的机器指令

## 内存溢出

- 申请内存时，没有足够的内存空间供其使用

## 堆栈溢出的情况以及解决方法

- 用new动态分配内存而不要用栈内存
- 函数传递参数尤其是大型对象不要用值传递，换引用传递
- 慎用递归，递归深度太深也会导致栈溢出

## 内存泄露

- 申请内存后，没有释放已申请的内存空间
- 解决方法：
  - `new`和 `malloc`要配合 `delete`和 `free`使用
  - 智能指针

### 检测内存泄露

- Windows下C 运行时库（CRT），可以提供检测和识别内存泄漏的方法，
- 原理：在分配内存和释放内存时分别做好记录，程序结束时对比分配内存和释放内存的记录就可以确定是不是有内存泄漏
- 检测是否存在内存泄露：`_CrtDumpMemoryLeaks();`
- 定位内存泄露的地方：使用 ` _CrtMemCheckpoint` 调用通过二进制搜索技术来划分程序和定位泄漏
  - `_CrtMemState s1, s2, s3`：存储内存状态的快照
  - `_CrtMemCheckpoint( &s1 )`：在给定点对内存状态拍快照
  - `_CrtMemDifference`( &s3, &s1, &s2)：比较两个内存状态（s1 和 s2），生成这两个状态之间差异的结果（s3）

## 如何减少内存碎片

### 内存碎片是什么

一部分内存以碎片的方式存在，导致不能够分配给程序使用

- 内部碎片：分配器分配的内存大于程序申请的内存。因为所有的内存分配必须起始于可被 4、8 或 16 整除，那么申请一个3字节的内存块，可能会获得一个4字节的内存，那么多余的这一个字节就是内部碎片了
- 外部碎片：内存块太小，无法分配给程序使用

### 如何解决内存碎片

#### 编程层面

- 尽可能少开辟内存空间，尽量复用内存空间
- 使用完内存空间后，尽快释放掉。
- 合理使用Union可以减小内存占用
- 合理安排struct或者class中的成员变量的位置
- 已知大小的数组静态开辟，未知大小的采用动态开辟
- 一次申请一大块内存，然后分成将其分成小块，每次用的时候将小块分配出去，释放的时候大块一起释放

#### slab

Slab Allocation的原理：将分配的内存分割成各种尺寸的块（chunk），并把尺寸相同的块分成组（chunk的集合）

![image-20210912101803548](images/image-20210912101803548.png)

![image-20210912103457562](images/image-20210912103457562.png)

## 野指针

野指针：当所指向的对象被释放或者收回，但是对该指针没有作任何的修改，以至于该指针仍旧指向已经回收的内存地址

### 什么情况会产生野指针

- 指针变量未初始化
- 指针释放之后未置空
- 指针操作超越变量作用域：不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放

## 如何定义一个只能在堆上（栈上）生成对象的类？

### 只能在堆上：

做法：将析构函数设置为私有

解释：编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。

### 只能在栈上：

做法：将new 和 delete 重载为私有

解释：只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。

## 栈和堆的区别

- 申请方式
  - 栈: 由系统自动分配
  - 堆: 需要程序员自己申请，并指定大小
- 申请后系统的响应
  - 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报overflow栈溢出
  - 操作系统有一个**记录空闲内存地址的链表**，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲结点链表中删除，并将该结点的空间分配给程序；另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间；另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中
- 申请大小的限制
  - 栈：在 Windows 下 , 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，如果申请的空间超过栈的剩余空间时，将提示 overflow 。因此，能从栈获得的空间较小
  - 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大
- 申请效率的比较
  - 栈由系统自动分配，速度较快。但程序员是无法控制的
  - 堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片 , 不过用起来最方便
- 堆和栈中的存储内容
  - 栈： 在函数调用时，存放返回地址、函数参数、局部变量。注意静态变量是不入栈的
  - 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排
- 存取效率：栈比堆快

## 只使用栈的缺点

栈的特点是先进后出，如果先进去的元素一直不用，但后面的元素要用到，就会导致先进去的元素一直占着栈空间不能释放，导致内存的使用率不高

## 只使用堆的缺点

堆之所以能与比栈更好的动态分配的性能是因为堆往往使用了较为复杂的数据结构，这就会导致操作堆的成本要远远大于栈的成本，所以如果仅仅使用堆会使的程序整体效率变慢。

## 栈为什么要有上限

- 栈的功能主要是函数调用、为函数调用提供一些保存现场、恢复现场的操作。栈帧中主要存储的数据有函数返回地址、函数参数、局部变量。在一个程序中这些信息占用内存不大，所以一般情况下栈空间都特别小。 而且栈空间用户无法操作，是由编译器和操作系统决定的
- 栈的地址空间必须连续，如果任其任意成长，会给内存管理带来困难。对于多线程程序来说，每个线程都必须分配一个栈，因此没办法让默认值太大

## new和malloc区别

- malloc是C++/C语言的标准库函数；而new是C++语言中的操作符
- new返回指定类型的指针；malloc返回void*，需要强制类型转换
- new可以自动计算所需空间的大小；malloc由用户自己计算所需空间大小。
- 而new除了分配内存处，还会对对象做初始化。
- new分配内存失败会抛出异常，malloc返回NULL

https://blog.csdn.net/nyist_zxp/article/details/80810742

`int* p = (int *) malloc ( sizeof(int)* 100 ); //分配可以放得下100个整数的内存空间`

## new分配的内存可以通过free释放吗

不行，new和delete不光分配内存，还做了构造函数和析构函数

## new、operator new、placement new的区别

### new

不能被重载

- 它先调用operator new分配内存
- 然后调用构造函数初始化那段内存
- 返回相应指针

### operator new

- 只分配所要求的空间，不调用相关对象的构造函数。
- 当无法满足所要求分配的空间时，调用new_handler
- 可以被重载
  - 重载时，返回类型必须声明为void*
  - 重载时，第一个参数类型必须为表达要求分配空间的大小（字节），类型为size_t
  - 重载时，可以带其它参数

### placement new

operator new重载的一个版本

它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。

**placement new的作用**

允许构造一个新对象到预分配的内存上

构造对象都是在一个预先准备好了的内存缓冲区中进行，不需要查找内存，内存分配的时间是常数；而且不会出现在程序运行中途出现内存不足的异常。所以，placement new非常适合那些对时间要求比较高，长时间运行不希望被打断的应用程序。

## main函数执行前后会执行什么代码

### main函数执行前：

1. 设置栈指针
2. 初始化静态和全局变量，即data段的内容
3. 将未初始化部分的全局变量赋初值，即bss段的内容
4. 运行全局构造器，估计是C++中构造函数之类的吧
5. 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数

### main函数执行后：

1. 全局对象的析构函数会在main函数之后执行；
2. 可以用_onexit 注册一个函数，它会在main 之后执行;

## 大端、小端存储

- 大端存储：数据的高字节存储在低地址中，数据的低字节存储在高地址中
  - 接收数据的程序可以优先得到数据的最高位，以便快速反应。（通信协议）
- 小端存储：数据的高字节存储在高地址中，数据的低字节存储在低地址中
  - x86结构、ARM和DSP都是小端存储
  - 计算机通常采用小端序列，是因为CPU读取内存中的数据时，是从低地址向高地址方向进行读取的
